"use strict";(self.webpackChunkmikechesterwang_github_io=self.webpackChunkmikechesterwang_github_io||[]).push([[67],{3905:function(e,r,n){n.d(r,{Zo:function(){return l},kt:function(){return g}});var t=n(7294);function s(e,r,n){return r in e?Object.defineProperty(e,r,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[r]=n,e}function o(e,r){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);r&&(t=t.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),n.push.apply(n,t)}return n}function a(e){for(var r=1;r<arguments.length;r++){var n=null!=arguments[r]?arguments[r]:{};r%2?o(Object(n),!0).forEach((function(r){s(e,r,n[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(n,r))}))}return e}function i(e,r){if(null==e)return{};var n,t,s=function(e,r){if(null==e)return{};var n,t,s={},o=Object.keys(e);for(t=0;t<o.length;t++)n=o[t],r.indexOf(n)>=0||(s[n]=e[n]);return s}(e,r);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(t=0;t<o.length;t++)n=o[t],r.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var p=t.createContext({}),c=function(e){var r=t.useContext(p),n=r;return e&&(n="function"==typeof e?e(r):a(a({},r),e)),n},l=function(e){var r=c(e.components);return t.createElement(p.Provider,{value:r},e.children)},u={inlineCode:"code",wrapper:function(e){var r=e.children;return t.createElement(t.Fragment,{},r)}},f=t.forwardRef((function(e,r){var n=e.components,s=e.mdxType,o=e.originalType,p=e.parentName,l=i(e,["components","mdxType","originalType","parentName"]),f=c(n),g=s,d=f["".concat(p,".").concat(g)]||f[g]||u[g]||o;return n?t.createElement(d,a(a({ref:r},l),{},{components:n})):t.createElement(d,a({ref:r},l))}));function g(e,r){var n=arguments,s=r&&r.mdxType;if("string"==typeof e||s){var o=n.length,a=new Array(o);a[0]=f;var i={};for(var p in r)hasOwnProperty.call(r,p)&&(i[p]=r[p]);i.originalType=e,i.mdxType="string"==typeof e?e:s,a[1]=i;for(var c=2;c<o;c++)a[c]=n[c];return t.createElement.apply(null,a)}return t.createElement.apply(null,n)}f.displayName="MDXCreateElement"},3438:function(e,r,n){n.r(r),n.d(r,{assets:function(){return l},contentTitle:function(){return p},default:function(){return g},frontMatter:function(){return i},metadata:function(){return c},toc:function(){return u}});var t=n(7462),s=n(3366),o=(n(7294),n(3905)),a=["components"],i={title:"Go HTTP Reverse Proxy",description:"go reverseproxy in httputils",authors:["mike"],tags:["go"],hide_table_of_contents:!1},p=void 0,c={permalink:"/blog/go_reverse_proxy",source:"@site/blog/go_reverse_proxy.md",title:"Go HTTP Reverse Proxy",description:"go reverseproxy in httputils",date:"2024-03-09T07:01:23.000Z",formattedDate:"March 9, 2024",tags:[{label:"go",permalink:"/blog/tags/go"}],readingTime:4.595,truncated:!1,authors:[{name:"Mike Wang",title:"Software Engineer",url:"https://github.com/mikechesterwang",imageURL:"https://avatars.githubusercontent.com/u/52522981",key:"mike"}],frontMatter:{title:"Go HTTP Reverse Proxy",description:"go reverseproxy in httputils",authors:["mike"],tags:["go"],hide_table_of_contents:!1},nextItem:{title:"Index",permalink:"/blog/index"}},l={authorsImageUrls:[void 0]},u=[{value:"Code",id:"code",level:3}],f={toc:u};function g(e){var r=e.components,n=(0,s.Z)(e,a);return(0,o.kt)("wrapper",(0,t.Z)({},f,n,{components:r,mdxType:"MDXLayout"}),(0,o.kt)("h3",{id:"code"},"Code"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"http_proxy.go")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'package proxy\n\nimport (\n    "crypto/tls"\n    "fmt"\n    "net"\n    "net/http"\n    "net/http/httputil"\n    "net/url"\n    "strings"\n    "sync"\n\n    "github.com/gorilla/mux"\n    "github.com/pkg/errors"\n)\n\ntype HTTPProxy struct {\n    router    *mux.Router\n    listeners map[string]*ProxyListener\n    mu        sync.RWMutex\n\n    listener net.Listener\n}\n\nfunc NewHTTPProxy() (*HTTPProxy, error) {\n    return &HTTPProxy{\n        router:    mux.NewRouter(),\n        listeners: make(map[string]*ProxyListener),\n    }, nil\n}\n\nfunc (p *HTTPProxy) AddListener(namespace string, name string, backendURL string) error {\n    base := fmt.Sprintf("/%s/%s", namespace, name)\n\n    listener, err := NewHTTPListener(\n        base,\n        backendURL,\n    )\n    if err != nil {\n        return errors.Wrapf(err, "failed to create listener, base: %s, backend: %s", base, backendURL)\n    }\n\n    p.mu.Lock()\n    defer p.mu.Unlock()\n    p.listeners[base] = listener\n\n    return nil\n}\n\nfunc (p *HTTPProxy) RemoveListener(namespace string, name string) {\n    p.mu.Lock()\n    defer p.mu.Unlock()\n\n    base := fmt.Sprintf("/%s/%s", namespace, name)\n\n    delete(p.listeners, base)\n}\n\nfunc (p *HTTPProxy) Serve(netListener net.Listener) error {\n    p.router.PathPrefix("/{namespace}/{name}").HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        p.mu.RLock()\n        defer p.mu.RUnlock()\n\n        vars := mux.Vars(r)\n        base := fmt.Sprintf("/%s/%s", vars["namespace"], vars["name"])\n\n        listener, ok := p.listeners[base]\n        if !ok {\n            w.WriteHeader(http.StatusNotFound)\n            return\n        }\n\n        listener.ServeHTTP(w, r)\n    })\n\n    p.listener = netListener\n\n    return http.Serve(netListener, p.router)\n}\n\nfunc (p *HTTPProxy) Close() error {\n    return p.listener.Close()\n}\n\ntype ProxyListener struct {\n    base    *url.URL\n    backend *url.URL\n}\n\nfunc NewHTTPListener(basePathRaw, backendRaw string) (*ProxyListener, error) {\n    basePath, err := url.Parse(basePathRaw)\n    if err != nil {\n        return nil, errors.Wrapf(err, "failed to parse base path, raw: %s", basePathRaw)\n    }\n    backend, err := url.Parse(backendRaw)\n    if err != nil {\n        return nil, errors.Wrapf(err, "failed to parse backend url, raw: %s", backendRaw)\n    }\n    return &ProxyListener{\n        base:    basePath,\n        backend: backend,\n    }, nil\n}\n\nfunc removeBasePathFromRequest(base *url.URL, req *url.URL) (string, string) {\n    if base.Path == "/" {\n        return req.Path, req.RawPath\n    }\n    bpath := base.Path\n    if strings.HasSuffix(base.Path, "/") {\n        bpath = base.Path[:len(base.Path)-1]\n    }\n    return req.Path[len(bpath):], req.EscapedPath()[len(bpath):]\n}\n\nfunc rewriteRequestURL(req *http.Request, target *url.URL, base *url.URL) {\n    targetQuery := target.RawQuery\n    req.URL.Scheme = target.Scheme\n    req.URL.Host = target.Host\n    req.URL.Path, req.URL.RawPath = removeBasePathFromRequest(base, req.URL)\n    if targetQuery == "" || req.URL.RawQuery == "" {\n        req.URL.RawQuery = targetQuery + req.URL.RawQuery\n    } else {\n        req.URL.RawQuery = targetQuery + "&" + req.URL.RawQuery\n    }\n}\n\nfunc (h *ProxyListener) ServeHTTP(rw http.ResponseWriter, req *http.Request) {\n    proxy := &httputil.ReverseProxy{\n        Director: func(r *http.Request) {\n            rewriteRequestURL(r, h.backend, h.base)\n        },\n        Transport: &http.Transport{\n            TLSClientConfig: &tls.Config{\n                InsecureSkipVerify: true,\n            },\n        },\n    }\n    proxy.ServeHTTP(rw, req)\n}\n\n')),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"http_proxy_test.go")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'package proxy\n\nimport (\n    "crypto/tls"\n    "crypto/x509"\n    "encoding/pem"\n    "fmt"\n    "io"\n    "net"\n    "net/http"\n    "strings"\n    "testing"\n    "time"\n\n    "github.com/pkg/errors"\n    "github.com/stretchr/testify/assert"\n    "github.com/stretchr/testify/require"\n    "golang.org/x/net/nettest"\n)\n\nfunc getTestCertificate() (*x509.CertPool, tls.Certificate, error) {\n    const caPEM = `-----BEGIN CERTIFICATE-----\nMIIDLzCCAhegAwIBAgIUAQHLhZGIh0u+p9b6+hEdpfR07kMwDQYJKoZIhvcNAQEL\nBQAwJzELMAkGA1UEBhMCVVMxGDAWBgNVBAMMD0V4YW1wbGUtUm9vdC1DQTAeFw0y\nMzA2MDUwODE4MzlaFw0yNjAzMjUwODE4MzlaMCcxCzAJBgNVBAYTAlVTMRgwFgYD\nVQQDDA9FeGFtcGxlLVJvb3QtQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEK\nAoIBAQDxDadnQbgaPOaAdqu8ClNoAiLTl4BaLMKqU5qbjkmQKIaq/Naa97FYv6Ng\nCspx85U4SUcOKxDnLH4+oiwZ/ob5M3I30M+SJSzm8xPAeWNyE5HTZIgH5L+Rx0Yn\nJVeK1lYc6Dna6b0BcfEzW2V3uJ9ZFU7ixuRXV3DJdocN+HpGtPvjn3zYHQaCRhxk\nans9psdFncANjyU6P2vLY0yuny3qMZUJXSOuVUKqM2IwRZku9EDARra4JVx5TBiV\nLXGxPj69wHdYloVu2fuFJS/Vf3V40or+bH3PRJF1brwqS28oNuOpcjo8Q+9brpbK\n9u/2ViFBfwrxcabobY7x/MpxtPm1AgMBAAGjUzBRMB0GA1UdDgQWBBS3G2Bc5HqV\nI6YLnnBgzUWsddWZCTAfBgNVHSMEGDAWgBS3G2Bc5HqVI6YLnnBgzUWsddWZCTAP\nBgNVHRMBAf8EBTADAQH/MA0GCSqGSIb3DQEBCwUAA4IBAQDMOF5IpSFwINyvUK+r\nRRT5mVEG3GKuG0leQJWFe5WuD2ksxTM4CKV6V0u+gY0R6uKtd/Z37ie/OLqXJq9H\nQ0zVqp6pen1GwgIWqtcVYVKxbRNO6OY3RBrFRwmeNjGzw3eP4676qCcckSQHqqVM\n/3b3Jxdvq9sjfdpp2XiIG1kRFLGFBouwzaEwfMADVdSLiI3JN2A19YhHwc6QrTCI\nWRmsEMe54OZqLtYU2Lgwzz9HT2aPaWVBV0ftMOd3LtJ9JjPSefqBLyWnWFunIaNi\n94x0TvZdlfspj5jfK/07tukC2Iz83f3D8z0qHJ9Vp6V7Fw+MtU5Ak3JDPx18XZzJ\nHDPL\n-----END CERTIFICATE-----`\n    const certPEM = `-----BEGIN CERTIFICATE-----\nMIIDjTCCAnWgAwIBAgIUXc2UkcCEjOerIOmkCe2EUHou8vcwDQYJKoZIhvcNAQEL\nBQAwJzELMAkGA1UEBhMCVVMxGDAWBgNVBAMMD0V4YW1wbGUtUm9vdC1DQTAeFw0y\nMzA2MDUwODE4MzlaFw0yNjAzMjUwODE4MzlaMG0xCzAJBgNVBAYTAlVTMRIwEAYD\nVQQIDAlZb3VyU3RhdGUxETAPBgNVBAcMCFlvdXJDaXR5MR0wGwYDVQQKDBRFeGFt\ncGxlLUNlcnRpZmljYXRlczEYMBYGA1UEAwwPbG9jYWxob3N0LmxvY2FsMIIBIjAN\nBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAtV1EDl/Hr3wJkxgKExqGGliXoO1v\n+m0SPtGo4ORuSTWiHQFuSd12QzXtc0HPeiKwC5echrJ8TgcKKwT10MTDGvb3sxvO\nZ4fdxh+B4SP9H6qNubBI+EOixGhNZq/iPzzZe9zEfLlTu+REscjrIbWvpWxSkto7\nKIgVbelOoTJoXjLNKt5QVfE9ME7+Amxgz5pqIVRz/k1ogDFcGhrXulms+YPS+y+L\nvAwaMqn2fO82XkEQgSRHe6krXPjMX+0oYysBkHdLaDvolRzE7iS8boLAFmiSL8ce\nqEdl0LLbiRsmwRTq6sRDHU88mLrDiGDWrSeQh4cZ1+jXX3p/84XyNtjTqQIDAQAB\no2swaTAfBgNVHSMEGDAWgBS3G2Bc5HqVI6YLnnBgzUWsddWZCTAJBgNVHRMEAjAA\nMAsGA1UdDwQEAwIE8DAuBgNVHREEJzAlgglsb2NhbGhvc3SCC2Zha2UxLmxvY2Fs\nggtmYWtlMi5sb2NhbDANBgkqhkiG9w0BAQsFAAOCAQEA0Suhn7RuEsVkLOsc+Wkr\nUMdjYeijcZz81W8yAwwa/mSqzp/bZnJBLRSeCLZ0RScxd08CFOSJPQ5shl9j6TPU\nMrbm3djH0WepsGlbVj3HWM2A1XmZvKA7Q48ZZf6uBo9qkka29diqMzqBVYsV4lmB\nEbsaxGItrAhxdgLus2UubVMtLj6MN88lmbpW8O3P53rYkX5nFlEzJUhNySGFxPBq\nNjXxtv1h65+CGawNBoD0vz0QBYa7BW0IVXRb+WlIVSf3r2iEShSwz4mr389SgHk0\n+0axUYUyVJ5/oB9ZMxyTSaXcl7k+KRT/M70KgAxm3dHri6uPjRM2AWrM3Bor/fJw\n7w==\n-----END CERTIFICATE-----`\n    const priPEM = `-----BEGIN PRIVATE KEY-----\nMIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQC1XUQOX8evfAmT\nGAoTGoYaWJeg7W/6bRI+0ajg5G5JNaIdAW5J3XZDNe1zQc96IrALl5yGsnxOBwor\nBPXQxMMa9vezG85nh93GH4HhI/0fqo25sEj4Q6LEaE1mr+I/PNl73MR8uVO75ESx\nyOshta+lbFKS2jsoiBVt6U6hMmheMs0q3lBV8T0wTv4CbGDPmmohVHP+TWiAMVwa\nGte6Waz5g9L7L4u8DBoyqfZ87zZeQRCBJEd7qStc+Mxf7ShjKwGQd0toO+iVHMTu\nJLxugsAWaJIvxx6oR2XQstuJGybBFOrqxEMdTzyYusOIYNatJ5CHhxnX6Ndfen/z\nhfI22NOpAgMBAAECggEALcLSoS3ZnJWXdN3j7N4MaCliWOCQGIfcyqzsB5KboS0/\nMkJiKZEPffXla+d3CkImWUZv4Cy44Jc2IZSm0X5UHEGkTjT953GIq6zXgI8sFwlZ\nqTipsLqgHx6SKQ7H71zTI0WY7j90uTvneVRQv7iwEPU8AIG/24I6pfjwNgwZ+Wo7\nHN4QcNn8qdWIerOiqTa/hxuKwTeofspaI1jgaw1PCXGXTYZ2furULUMF4IQVbQZA\nUU9ZptXZTIO2i95Ne+LRAc75GGKmzV74XCaEiY7ySpeerq0Wbo1f3YDF9fcxjHHr\nzgnM0/o/au+XB2vBuwOmAZonUSXAyvKX34v0ucFCYQKBgQDknrVgZ+wwUQBjGtsJ\n6ySPyLD1oUudDnnYIWkHXs8ibSj+QVqB/ANX+PJhq5kaEZnswWujAInVob0PjN/Q\nLWmNaFKrN4SBRxsiHOJQqlXH1PQsU0uKJUbIAAbif+yHZPMGinDqxYu99GXeBKIT\n+3dnKS+xJFliGYFPjSJ/INpGWwKBgQDLFb156qNezXBBumwZ4fYmq/Fd9uqbqWfd\nbXB8cxuph8M5zU+2UKvyRzqw4Ioo6kIeTmcaSpSepJ1onLr2dSmpF+s83yoaJSuI\nY4t7foR5CXHG/KApM06qxmHbNRHF0juGf3MBrnlBYRiM+frPeEMId3sQWDQmXpE8\nAkHxkr5VSwKBgQCsuohY9UuK2bhMKF8zqDgwdjXU7298kxJVzDBZRDWFUio1p1Tl\nfm1cSxd92bNL8d509VIIjoCVKqT4GbyDwbvM/fPvrntrXTjP1jjbL0auO2PcFXau\nQimvM+3/tR0U0p2W5IQZrPU+qGdKjf+Sz1xQUdrZoJfzuUdsvjpBCKZBnwKBgQCA\nGb+B9qKEezvTCf+EOAcnj4/ZgJWuCKaugojQx17siel4PWyJiMtdMNbxmUEs289H\nBJd+ewrSIu3zfeFk8rSLp73HkNEi2s1h48Co7j4rhuyQ4us38dguWqKBPjFuwdSw\nWxY1OlPcDJ4K1ugBFE/cOFmVDr4eccpUuuvTsIeEjwKBgE9Bn4zuQO9wGLNoEl6G\nPMPeNsqJL0tL/AfcQ9XYZIIkDa9Ed/PSWPhQNWzJbt44rug5nre25WqWS3uDG2p4\nRnJlN9UjHPvwBWK3VL6is+bFpWSylZeSibbQwKq8MYfBV0EsJCMMvwaAc5mb50iH\noIkpaySJ6Bk+O6pK+ul2Ywzk\n-----END PRIVATE KEY-----`\n    pool := x509.NewCertPool()\n    caBlock, _ := pem.Decode([]byte(caPEM))\n    ca, err := x509.ParseCertificate(caBlock.Bytes)\n    if err != nil {\n        return nil, tls.Certificate{}, errors.Wrap(err, "failed to parse root certificate")\n    }\n    pool.AddCert(ca)\n\n    cert, err := tls.X509KeyPair([]byte(certPEM), []byte(priPEM))\n    if err != nil {\n        return nil, tls.Certificate{}, errors.Wrap(err, "failed to parse certificate")\n    }\n    return pool, cert, nil\n}\n\nfunc getTestTLSListener() (net.Listener, error) {\n    listener, err := nettest.NewLocalListener("tcp")\n    if err != nil {\n        return nil, err\n    }\n\n    pool, cert, err := getTestCertificate()\n    if err != nil {\n        return nil, err\n    }\n\n    tlsListener := tls.NewListener(listener, &tls.Config{\n        Certificates: []tls.Certificate{cert},\n        RootCAs:      pool,\n        NextProtos:   []string{"h2"},\n    })\n\n    return tlsListener, nil\n}\n\nfunc prepareProxyAndBackends(t *testing.T) (net.Listener, net.Listener) {\n    // prepare tls backend\n    tlsBackendListener, err := getTestTLSListener()\n    require.NoError(t, err)\n    go http.Serve(tlsBackendListener, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        w.Write([]byte(r.URL.String()))\n    }))\n\n    // prepare tcp backend\n    backendListener, err := nettest.NewLocalListener("tcp")\n    require.NoError(t, err)\n    go http.Serve(backendListener, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        w.Write([]byte(r.URL.String()))\n    }))\n\n    // wait for listening\n    time.Sleep(10 * time.Millisecond)\n    return tlsBackendListener, backendListener\n}\n\nfunc getPort(l net.Listener) string {\n    return strings.Split(l.Addr().String(), ":")[1]\n}\n\nfunc testProxy(t *testing.T, proxy *HTTPProxy, proxyURL string) {\n    tlsListener, tcpListener := prepareProxyAndBackends(t)\n\n    tlsBackendURL := fmt.Sprintf("https://localhost:%s", getPort(tlsListener))\n    defer tlsListener.Close()\n\n    tcpBackendURL := fmt.Sprintf("http://localhost:%s", getPort(tcpListener))\n    defer tcpListener.Close()\n\n    var (\n        tlsNamespace = "tls"\n        tlsName      = "tls_service"\n        tlsBase      = fmt.Sprintf("/%s/%s", tlsNamespace, tlsName)\n        tcpNamespace = "tcp"\n        tcpName      = "tcp_service"\n        tcpBase      = fmt.Sprintf("/%s/%s", tcpNamespace, tcpName)\n        path         = "/api/v1"\n    )\n\n    // add listeners\n    err := proxy.AddListener(tlsNamespace, tlsName, tlsBackendURL)\n    require.NoError(t, err)\n    err = proxy.AddListener(tcpNamespace, tcpName, tcpBackendURL)\n    require.NoError(t, err)\n\n    // send request to TLS backend\n    addr := fmt.Sprintf("%s%s%s", proxyURL, tlsBase, path)\n    httpClient := &http.Client{\n        Transport: &http.Transport{\n            TLSClientConfig: &tls.Config{\n                InsecureSkipVerify: true,\n            },\n        },\n    }\n    res, err := httpClient.Get(addr)\n    require.NoError(t, err)\n    b, err := io.ReadAll(res.Body)\n    require.NoError(t, err)\n    assert.Equal(t, path, string(b))\n\n    // send request to TCP backend\n    addr = fmt.Sprintf("%s%s%s", proxyURL, tcpBase, path)\n    res, err = httpClient.Get(addr)\n    require.NoError(t, err)\n    b, err = io.ReadAll(res.Body)\n    require.NoError(t, err)\n    assert.Equal(t, path, string(b))\n}\n\nfunc TestProxy_https_tls_and_tcp_backend(t *testing.T) {\n    proxyListener, err := getTestTLSListener()\n    require.NoError(t, err)\n    proxy, err := NewHTTPProxy()\n    require.NoError(t, err)\n    go proxy.Serve(proxyListener)\n    defer proxy.Close()\n    time.Sleep(10 * time.Millisecond)\n\n    testProxy(t, proxy, fmt.Sprintf("https://localhost:%s", getPort(proxyListener)))\n}\n\nfunc TestProxy_http_tls_and_tcp_backend(t *testing.T) {\n    proxyListener, err := nettest.NewLocalListener("tcp")\n    require.NoError(t, err)\n    proxy, err := NewHTTPProxy()\n    require.NoError(t, err)\n    go proxy.Serve(proxyListener)\n    defer proxy.Close()\n    time.Sleep(10 * time.Millisecond)\n\n    testProxy(t, proxy, fmt.Sprintf("http://localhost:%s", getPort(proxyListener)))\n}\n\nfunc TestRemoveListener(t *testing.T) {\n    // prepare backend\n    backendListener, err := nettest.NewLocalListener("tcp")\n    require.NoError(t, err)\n    go http.Serve(backendListener, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        w.Write([]byte(r.URL.String()))\n    }))\n    backendURL := fmt.Sprintf("http://localhost:%s", getPort(backendListener))\n\n    // proxy\n    proxyListener, err := nettest.NewLocalListener("tcp")\n    require.NoError(t, err)\n    proxy, err := NewHTTPProxy()\n    require.NoError(t, err)\n    go proxy.Serve(proxyListener)\n    defer proxy.Close()\n    time.Sleep(10 * time.Millisecond)\n    proxyURL := fmt.Sprintf("http://localhost:%s", getPort(proxyListener))\n\n    // add listener\n    err = proxy.AddListener("test", "test", backendURL)\n    require.NoError(t, err)\n\n    // send request\n    res, err := http.DefaultClient.Get(fmt.Sprintf("%s/test/test/api/v1", proxyURL))\n    require.NoError(t, err)\n    require.Equal(t, http.StatusOK, res.StatusCode)\n    b, err := io.ReadAll(res.Body)\n    require.NoError(t, err)\n    assert.Equal(t, "/api/v1", string(b))\n\n    // remove listener\n    proxy.RemoveListener("test", "test")\n    require.NoError(t, err)\n\n    // send request\n    res, err = http.DefaultClient.Get(fmt.Sprintf("%s/test/test/api/v1", proxyURL))\n    require.NoError(t, err)\n    require.Equal(t, http.StatusNotFound, res.StatusCode)\n}\n\n')))}g.isMDXComponent=!0}}]);