"use strict";(self.webpackChunkmikechesterwang_github_io=self.webpackChunkmikechesterwang_github_io||[]).push([[1477],{10:function(e){e.exports=JSON.parse('{"blogPosts":[{"id":"/go_reverse_proxy","metadata":{"permalink":"/blog/go_reverse_proxy","source":"@site/blog/go_reverse_proxy.md","title":"Go HTTP Reverse Proxy","description":"go reverseproxy in httputils","date":"2024-07-10T13:16:41.000Z","formattedDate":"July 10, 2024","tags":[{"label":"go","permalink":"/blog/tags/go"}],"readingTime":4.595,"truncated":false,"authors":[{"name":"Mike Wang","title":"Software Engineer","url":"https://github.com/mikechesterwang","imageURL":"https://avatars.githubusercontent.com/u/52522981","key":"mike"}],"frontMatter":{"title":"Go HTTP Reverse Proxy","description":"go reverseproxy in httputils","authors":["mike"],"tags":["go"],"hide_table_of_contents":false},"nextItem":{"title":"Golang Web Starter","permalink":"/blog/go_web_started"}},"content":"### Code\\n\\n`http_proxy.go`\\n\\n```go\\npackage proxy\\n\\nimport (\\n\\t\\"crypto/tls\\"\\n\\t\\"fmt\\"\\n\\t\\"net\\"\\n\\t\\"net/http\\"\\n\\t\\"net/http/httputil\\"\\n\\t\\"net/url\\"\\n\\t\\"strings\\"\\n\\t\\"sync\\"\\n\\n\\t\\"github.com/gorilla/mux\\"\\n\\t\\"github.com/pkg/errors\\"\\n)\\n\\ntype HTTPProxy struct {\\n\\trouter    *mux.Router\\n\\tlisteners map[string]*ProxyListener\\n\\tmu        sync.RWMutex\\n\\n\\tlistener net.Listener\\n}\\n\\nfunc NewHTTPProxy() (*HTTPProxy, error) {\\n\\treturn &HTTPProxy{\\n\\t\\trouter:    mux.NewRouter(),\\n\\t\\tlisteners: make(map[string]*ProxyListener),\\n\\t}, nil\\n}\\n\\nfunc (p *HTTPProxy) AddListener(namespace string, name string, backendURL string) error {\\n\\tbase := fmt.Sprintf(\\"/%s/%s\\", namespace, name)\\n\\n\\tlistener, err := NewHTTPListener(\\n\\t\\tbase,\\n\\t\\tbackendURL,\\n\\t)\\n\\tif err != nil {\\n\\t\\treturn errors.Wrapf(err, \\"failed to create listener, base: %s, backend: %s\\", base, backendURL)\\n\\t}\\n\\n\\tp.mu.Lock()\\n\\tdefer p.mu.Unlock()\\n\\tp.listeners[base] = listener\\n\\n\\treturn nil\\n}\\n\\nfunc (p *HTTPProxy) RemoveListener(namespace string, name string) {\\n\\tp.mu.Lock()\\n\\tdefer p.mu.Unlock()\\n\\n\\tbase := fmt.Sprintf(\\"/%s/%s\\", namespace, name)\\n\\n\\tdelete(p.listeners, base)\\n}\\n\\nfunc (p *HTTPProxy) Serve(netListener net.Listener) error {\\n\\tp.router.PathPrefix(\\"/{namespace}/{name}\\").HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\\n\\t\\tp.mu.RLock()\\n\\t\\tdefer p.mu.RUnlock()\\n\\n\\t\\tvars := mux.Vars(r)\\n\\t\\tbase := fmt.Sprintf(\\"/%s/%s\\", vars[\\"namespace\\"], vars[\\"name\\"])\\n\\n\\t\\tlistener, ok := p.listeners[base]\\n\\t\\tif !ok {\\n\\t\\t\\tw.WriteHeader(http.StatusNotFound)\\n\\t\\t\\treturn\\n\\t\\t}\\n\\n\\t\\tlistener.ServeHTTP(w, r)\\n\\t})\\n\\n\\tp.listener = netListener\\n\\n\\treturn http.Serve(netListener, p.router)\\n}\\n\\nfunc (p *HTTPProxy) Close() error {\\n\\treturn p.listener.Close()\\n}\\n\\ntype ProxyListener struct {\\n\\tbase    *url.URL\\n\\tbackend *url.URL\\n}\\n\\nfunc NewHTTPListener(basePathRaw, backendRaw string) (*ProxyListener, error) {\\n\\tbasePath, err := url.Parse(basePathRaw)\\n\\tif err != nil {\\n\\t\\treturn nil, errors.Wrapf(err, \\"failed to parse base path, raw: %s\\", basePathRaw)\\n\\t}\\n\\tbackend, err := url.Parse(backendRaw)\\n\\tif err != nil {\\n\\t\\treturn nil, errors.Wrapf(err, \\"failed to parse backend url, raw: %s\\", backendRaw)\\n\\t}\\n\\treturn &ProxyListener{\\n\\t\\tbase:    basePath,\\n\\t\\tbackend: backend,\\n\\t}, nil\\n}\\n\\nfunc removeBasePathFromRequest(base *url.URL, req *url.URL) (string, string) {\\n\\tif base.Path == \\"/\\" {\\n\\t\\treturn req.Path, req.RawPath\\n\\t}\\n\\tbpath := base.Path\\n\\tif strings.HasSuffix(base.Path, \\"/\\") {\\n\\t\\tbpath = base.Path[:len(base.Path)-1]\\n\\t}\\n\\treturn req.Path[len(bpath):], req.EscapedPath()[len(bpath):]\\n}\\n\\nfunc rewriteRequestURL(req *http.Request, target *url.URL, base *url.URL) {\\n\\ttargetQuery := target.RawQuery\\n\\treq.URL.Scheme = target.Scheme\\n\\treq.URL.Host = target.Host\\n\\treq.URL.Path, req.URL.RawPath = removeBasePathFromRequest(base, req.URL)\\n\\tif targetQuery == \\"\\" || req.URL.RawQuery == \\"\\" {\\n\\t\\treq.URL.RawQuery = targetQuery + req.URL.RawQuery\\n\\t} else {\\n\\t\\treq.URL.RawQuery = targetQuery + \\"&\\" + req.URL.RawQuery\\n\\t}\\n}\\n\\nfunc (h *ProxyListener) ServeHTTP(rw http.ResponseWriter, req *http.Request) {\\n\\tproxy := &httputil.ReverseProxy{\\n\\t\\tDirector: func(r *http.Request) {\\n\\t\\t\\trewriteRequestURL(r, h.backend, h.base)\\n\\t\\t},\\n\\t\\tTransport: &http.Transport{\\n\\t\\t\\tTLSClientConfig: &tls.Config{\\n\\t\\t\\t\\tInsecureSkipVerify: true,\\n\\t\\t\\t},\\n\\t\\t},\\n\\t}\\n\\tproxy.ServeHTTP(rw, req)\\n}\\n\\n```\\n\\n\\n`http_proxy_test.go`\\n\\n\\n```go\\npackage proxy\\n\\nimport (\\n\\t\\"crypto/tls\\"\\n\\t\\"crypto/x509\\"\\n\\t\\"encoding/pem\\"\\n\\t\\"fmt\\"\\n\\t\\"io\\"\\n\\t\\"net\\"\\n\\t\\"net/http\\"\\n\\t\\"strings\\"\\n\\t\\"testing\\"\\n\\t\\"time\\"\\n\\n\\t\\"github.com/pkg/errors\\"\\n\\t\\"github.com/stretchr/testify/assert\\"\\n\\t\\"github.com/stretchr/testify/require\\"\\n\\t\\"golang.org/x/net/nettest\\"\\n)\\n\\nfunc getTestCertificate() (*x509.CertPool, tls.Certificate, error) {\\n\\tconst caPEM = `-----BEGIN CERTIFICATE-----\\nMIIDLzCCAhegAwIBAgIUAQHLhZGIh0u+p9b6+hEdpfR07kMwDQYJKoZIhvcNAQEL\\nBQAwJzELMAkGA1UEBhMCVVMxGDAWBgNVBAMMD0V4YW1wbGUtUm9vdC1DQTAeFw0y\\nMzA2MDUwODE4MzlaFw0yNjAzMjUwODE4MzlaMCcxCzAJBgNVBAYTAlVTMRgwFgYD\\nVQQDDA9FeGFtcGxlLVJvb3QtQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEK\\nAoIBAQDxDadnQbgaPOaAdqu8ClNoAiLTl4BaLMKqU5qbjkmQKIaq/Naa97FYv6Ng\\nCspx85U4SUcOKxDnLH4+oiwZ/ob5M3I30M+SJSzm8xPAeWNyE5HTZIgH5L+Rx0Yn\\nJVeK1lYc6Dna6b0BcfEzW2V3uJ9ZFU7ixuRXV3DJdocN+HpGtPvjn3zYHQaCRhxk\\nans9psdFncANjyU6P2vLY0yuny3qMZUJXSOuVUKqM2IwRZku9EDARra4JVx5TBiV\\nLXGxPj69wHdYloVu2fuFJS/Vf3V40or+bH3PRJF1brwqS28oNuOpcjo8Q+9brpbK\\n9u/2ViFBfwrxcabobY7x/MpxtPm1AgMBAAGjUzBRMB0GA1UdDgQWBBS3G2Bc5HqV\\nI6YLnnBgzUWsddWZCTAfBgNVHSMEGDAWgBS3G2Bc5HqVI6YLnnBgzUWsddWZCTAP\\nBgNVHRMBAf8EBTADAQH/MA0GCSqGSIb3DQEBCwUAA4IBAQDMOF5IpSFwINyvUK+r\\nRRT5mVEG3GKuG0leQJWFe5WuD2ksxTM4CKV6V0u+gY0R6uKtd/Z37ie/OLqXJq9H\\nQ0zVqp6pen1GwgIWqtcVYVKxbRNO6OY3RBrFRwmeNjGzw3eP4676qCcckSQHqqVM\\n/3b3Jxdvq9sjfdpp2XiIG1kRFLGFBouwzaEwfMADVdSLiI3JN2A19YhHwc6QrTCI\\nWRmsEMe54OZqLtYU2Lgwzz9HT2aPaWVBV0ftMOd3LtJ9JjPSefqBLyWnWFunIaNi\\n94x0TvZdlfspj5jfK/07tukC2Iz83f3D8z0qHJ9Vp6V7Fw+MtU5Ak3JDPx18XZzJ\\nHDPL\\n-----END CERTIFICATE-----`\\n\\tconst certPEM = `-----BEGIN CERTIFICATE-----\\nMIIDjTCCAnWgAwIBAgIUXc2UkcCEjOerIOmkCe2EUHou8vcwDQYJKoZIhvcNAQEL\\nBQAwJzELMAkGA1UEBhMCVVMxGDAWBgNVBAMMD0V4YW1wbGUtUm9vdC1DQTAeFw0y\\nMzA2MDUwODE4MzlaFw0yNjAzMjUwODE4MzlaMG0xCzAJBgNVBAYTAlVTMRIwEAYD\\nVQQIDAlZb3VyU3RhdGUxETAPBgNVBAcMCFlvdXJDaXR5MR0wGwYDVQQKDBRFeGFt\\ncGxlLUNlcnRpZmljYXRlczEYMBYGA1UEAwwPbG9jYWxob3N0LmxvY2FsMIIBIjAN\\nBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAtV1EDl/Hr3wJkxgKExqGGliXoO1v\\n+m0SPtGo4ORuSTWiHQFuSd12QzXtc0HPeiKwC5echrJ8TgcKKwT10MTDGvb3sxvO\\nZ4fdxh+B4SP9H6qNubBI+EOixGhNZq/iPzzZe9zEfLlTu+REscjrIbWvpWxSkto7\\nKIgVbelOoTJoXjLNKt5QVfE9ME7+Amxgz5pqIVRz/k1ogDFcGhrXulms+YPS+y+L\\nvAwaMqn2fO82XkEQgSRHe6krXPjMX+0oYysBkHdLaDvolRzE7iS8boLAFmiSL8ce\\nqEdl0LLbiRsmwRTq6sRDHU88mLrDiGDWrSeQh4cZ1+jXX3p/84XyNtjTqQIDAQAB\\no2swaTAfBgNVHSMEGDAWgBS3G2Bc5HqVI6YLnnBgzUWsddWZCTAJBgNVHRMEAjAA\\nMAsGA1UdDwQEAwIE8DAuBgNVHREEJzAlgglsb2NhbGhvc3SCC2Zha2UxLmxvY2Fs\\nggtmYWtlMi5sb2NhbDANBgkqhkiG9w0BAQsFAAOCAQEA0Suhn7RuEsVkLOsc+Wkr\\nUMdjYeijcZz81W8yAwwa/mSqzp/bZnJBLRSeCLZ0RScxd08CFOSJPQ5shl9j6TPU\\nMrbm3djH0WepsGlbVj3HWM2A1XmZvKA7Q48ZZf6uBo9qkka29diqMzqBVYsV4lmB\\nEbsaxGItrAhxdgLus2UubVMtLj6MN88lmbpW8O3P53rYkX5nFlEzJUhNySGFxPBq\\nNjXxtv1h65+CGawNBoD0vz0QBYa7BW0IVXRb+WlIVSf3r2iEShSwz4mr389SgHk0\\n+0axUYUyVJ5/oB9ZMxyTSaXcl7k+KRT/M70KgAxm3dHri6uPjRM2AWrM3Bor/fJw\\n7w==\\n-----END CERTIFICATE-----`\\n\\tconst priPEM = `-----BEGIN PRIVATE KEY-----\\nMIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQC1XUQOX8evfAmT\\nGAoTGoYaWJeg7W/6bRI+0ajg5G5JNaIdAW5J3XZDNe1zQc96IrALl5yGsnxOBwor\\nBPXQxMMa9vezG85nh93GH4HhI/0fqo25sEj4Q6LEaE1mr+I/PNl73MR8uVO75ESx\\nyOshta+lbFKS2jsoiBVt6U6hMmheMs0q3lBV8T0wTv4CbGDPmmohVHP+TWiAMVwa\\nGte6Waz5g9L7L4u8DBoyqfZ87zZeQRCBJEd7qStc+Mxf7ShjKwGQd0toO+iVHMTu\\nJLxugsAWaJIvxx6oR2XQstuJGybBFOrqxEMdTzyYusOIYNatJ5CHhxnX6Ndfen/z\\nhfI22NOpAgMBAAECggEALcLSoS3ZnJWXdN3j7N4MaCliWOCQGIfcyqzsB5KboS0/\\nMkJiKZEPffXla+d3CkImWUZv4Cy44Jc2IZSm0X5UHEGkTjT953GIq6zXgI8sFwlZ\\nqTipsLqgHx6SKQ7H71zTI0WY7j90uTvneVRQv7iwEPU8AIG/24I6pfjwNgwZ+Wo7\\nHN4QcNn8qdWIerOiqTa/hxuKwTeofspaI1jgaw1PCXGXTYZ2furULUMF4IQVbQZA\\nUU9ZptXZTIO2i95Ne+LRAc75GGKmzV74XCaEiY7ySpeerq0Wbo1f3YDF9fcxjHHr\\nzgnM0/o/au+XB2vBuwOmAZonUSXAyvKX34v0ucFCYQKBgQDknrVgZ+wwUQBjGtsJ\\n6ySPyLD1oUudDnnYIWkHXs8ibSj+QVqB/ANX+PJhq5kaEZnswWujAInVob0PjN/Q\\nLWmNaFKrN4SBRxsiHOJQqlXH1PQsU0uKJUbIAAbif+yHZPMGinDqxYu99GXeBKIT\\n+3dnKS+xJFliGYFPjSJ/INpGWwKBgQDLFb156qNezXBBumwZ4fYmq/Fd9uqbqWfd\\nbXB8cxuph8M5zU+2UKvyRzqw4Ioo6kIeTmcaSpSepJ1onLr2dSmpF+s83yoaJSuI\\nY4t7foR5CXHG/KApM06qxmHbNRHF0juGf3MBrnlBYRiM+frPeEMId3sQWDQmXpE8\\nAkHxkr5VSwKBgQCsuohY9UuK2bhMKF8zqDgwdjXU7298kxJVzDBZRDWFUio1p1Tl\\nfm1cSxd92bNL8d509VIIjoCVKqT4GbyDwbvM/fPvrntrXTjP1jjbL0auO2PcFXau\\nQimvM+3/tR0U0p2W5IQZrPU+qGdKjf+Sz1xQUdrZoJfzuUdsvjpBCKZBnwKBgQCA\\nGb+B9qKEezvTCf+EOAcnj4/ZgJWuCKaugojQx17siel4PWyJiMtdMNbxmUEs289H\\nBJd+ewrSIu3zfeFk8rSLp73HkNEi2s1h48Co7j4rhuyQ4us38dguWqKBPjFuwdSw\\nWxY1OlPcDJ4K1ugBFE/cOFmVDr4eccpUuuvTsIeEjwKBgE9Bn4zuQO9wGLNoEl6G\\nPMPeNsqJL0tL/AfcQ9XYZIIkDa9Ed/PSWPhQNWzJbt44rug5nre25WqWS3uDG2p4\\nRnJlN9UjHPvwBWK3VL6is+bFpWSylZeSibbQwKq8MYfBV0EsJCMMvwaAc5mb50iH\\noIkpaySJ6Bk+O6pK+ul2Ywzk\\n-----END PRIVATE KEY-----`\\n\\tpool := x509.NewCertPool()\\n\\tcaBlock, _ := pem.Decode([]byte(caPEM))\\n\\tca, err := x509.ParseCertificate(caBlock.Bytes)\\n\\tif err != nil {\\n\\t\\treturn nil, tls.Certificate{}, errors.Wrap(err, \\"failed to parse root certificate\\")\\n\\t}\\n\\tpool.AddCert(ca)\\n\\n\\tcert, err := tls.X509KeyPair([]byte(certPEM), []byte(priPEM))\\n\\tif err != nil {\\n\\t\\treturn nil, tls.Certificate{}, errors.Wrap(err, \\"failed to parse certificate\\")\\n\\t}\\n\\treturn pool, cert, nil\\n}\\n\\nfunc getTestTLSListener() (net.Listener, error) {\\n\\tlistener, err := nettest.NewLocalListener(\\"tcp\\")\\n\\tif err != nil {\\n\\t\\treturn nil, err\\n\\t}\\n\\n\\tpool, cert, err := getTestCertificate()\\n\\tif err != nil {\\n\\t\\treturn nil, err\\n\\t}\\n\\n\\ttlsListener := tls.NewListener(listener, &tls.Config{\\n\\t\\tCertificates: []tls.Certificate{cert},\\n\\t\\tRootCAs:      pool,\\n\\t\\tNextProtos:   []string{\\"h2\\"},\\n\\t})\\n\\n\\treturn tlsListener, nil\\n}\\n\\nfunc prepareProxyAndBackends(t *testing.T) (net.Listener, net.Listener) {\\n\\t// prepare tls backend\\n\\ttlsBackendListener, err := getTestTLSListener()\\n\\trequire.NoError(t, err)\\n\\tgo http.Serve(tlsBackendListener, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\\n\\t\\tw.Write([]byte(r.URL.String()))\\n\\t}))\\n\\n\\t// prepare tcp backend\\n\\tbackendListener, err := nettest.NewLocalListener(\\"tcp\\")\\n\\trequire.NoError(t, err)\\n\\tgo http.Serve(backendListener, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\\n\\t\\tw.Write([]byte(r.URL.String()))\\n\\t}))\\n\\n\\t// wait for listening\\n\\ttime.Sleep(10 * time.Millisecond)\\n\\treturn tlsBackendListener, backendListener\\n}\\n\\nfunc getPort(l net.Listener) string {\\n\\treturn strings.Split(l.Addr().String(), \\":\\")[1]\\n}\\n\\nfunc testProxy(t *testing.T, proxy *HTTPProxy, proxyURL string) {\\n\\ttlsListener, tcpListener := prepareProxyAndBackends(t)\\n\\n\\ttlsBackendURL := fmt.Sprintf(\\"https://localhost:%s\\", getPort(tlsListener))\\n\\tdefer tlsListener.Close()\\n\\n\\ttcpBackendURL := fmt.Sprintf(\\"http://localhost:%s\\", getPort(tcpListener))\\n\\tdefer tcpListener.Close()\\n\\n\\tvar (\\n\\t\\ttlsNamespace = \\"tls\\"\\n\\t\\ttlsName      = \\"tls_service\\"\\n\\t\\ttlsBase      = fmt.Sprintf(\\"/%s/%s\\", tlsNamespace, tlsName)\\n\\t\\ttcpNamespace = \\"tcp\\"\\n\\t\\ttcpName      = \\"tcp_service\\"\\n\\t\\ttcpBase      = fmt.Sprintf(\\"/%s/%s\\", tcpNamespace, tcpName)\\n\\t\\tpath         = \\"/api/v1\\"\\n\\t)\\n\\n\\t// add listeners\\n\\terr := proxy.AddListener(tlsNamespace, tlsName, tlsBackendURL)\\n\\trequire.NoError(t, err)\\n\\terr = proxy.AddListener(tcpNamespace, tcpName, tcpBackendURL)\\n\\trequire.NoError(t, err)\\n\\n\\t// send request to TLS backend\\n\\taddr := fmt.Sprintf(\\"%s%s%s\\", proxyURL, tlsBase, path)\\n\\thttpClient := &http.Client{\\n\\t\\tTransport: &http.Transport{\\n\\t\\t\\tTLSClientConfig: &tls.Config{\\n\\t\\t\\t\\tInsecureSkipVerify: true,\\n\\t\\t\\t},\\n\\t\\t},\\n\\t}\\n\\tres, err := httpClient.Get(addr)\\n\\trequire.NoError(t, err)\\n\\tb, err := io.ReadAll(res.Body)\\n\\trequire.NoError(t, err)\\n\\tassert.Equal(t, path, string(b))\\n\\n\\t// send request to TCP backend\\n\\taddr = fmt.Sprintf(\\"%s%s%s\\", proxyURL, tcpBase, path)\\n\\tres, err = httpClient.Get(addr)\\n\\trequire.NoError(t, err)\\n\\tb, err = io.ReadAll(res.Body)\\n\\trequire.NoError(t, err)\\n\\tassert.Equal(t, path, string(b))\\n}\\n\\nfunc TestProxy_https_tls_and_tcp_backend(t *testing.T) {\\n\\tproxyListener, err := getTestTLSListener()\\n\\trequire.NoError(t, err)\\n\\tproxy, err := NewHTTPProxy()\\n\\trequire.NoError(t, err)\\n\\tgo proxy.Serve(proxyListener)\\n\\tdefer proxy.Close()\\n\\ttime.Sleep(10 * time.Millisecond)\\n\\n\\ttestProxy(t, proxy, fmt.Sprintf(\\"https://localhost:%s\\", getPort(proxyListener)))\\n}\\n\\nfunc TestProxy_http_tls_and_tcp_backend(t *testing.T) {\\n\\tproxyListener, err := nettest.NewLocalListener(\\"tcp\\")\\n\\trequire.NoError(t, err)\\n\\tproxy, err := NewHTTPProxy()\\n\\trequire.NoError(t, err)\\n\\tgo proxy.Serve(proxyListener)\\n\\tdefer proxy.Close()\\n\\ttime.Sleep(10 * time.Millisecond)\\n\\n\\ttestProxy(t, proxy, fmt.Sprintf(\\"http://localhost:%s\\", getPort(proxyListener)))\\n}\\n\\nfunc TestRemoveListener(t *testing.T) {\\n\\t// prepare backend\\n\\tbackendListener, err := nettest.NewLocalListener(\\"tcp\\")\\n\\trequire.NoError(t, err)\\n\\tgo http.Serve(backendListener, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\\n\\t\\tw.Write([]byte(r.URL.String()))\\n\\t}))\\n\\tbackendURL := fmt.Sprintf(\\"http://localhost:%s\\", getPort(backendListener))\\n\\n\\t// proxy\\n\\tproxyListener, err := nettest.NewLocalListener(\\"tcp\\")\\n\\trequire.NoError(t, err)\\n\\tproxy, err := NewHTTPProxy()\\n\\trequire.NoError(t, err)\\n\\tgo proxy.Serve(proxyListener)\\n\\tdefer proxy.Close()\\n\\ttime.Sleep(10 * time.Millisecond)\\n\\tproxyURL := fmt.Sprintf(\\"http://localhost:%s\\", getPort(proxyListener))\\n\\n\\t// add listener\\n\\terr = proxy.AddListener(\\"test\\", \\"test\\", backendURL)\\n\\trequire.NoError(t, err)\\n\\n\\t// send request\\n\\tres, err := http.DefaultClient.Get(fmt.Sprintf(\\"%s/test/test/api/v1\\", proxyURL))\\n\\trequire.NoError(t, err)\\n\\trequire.Equal(t, http.StatusOK, res.StatusCode)\\n\\tb, err := io.ReadAll(res.Body)\\n\\trequire.NoError(t, err)\\n\\tassert.Equal(t, \\"/api/v1\\", string(b))\\n\\n\\t// remove listener\\n\\tproxy.RemoveListener(\\"test\\", \\"test\\")\\n\\trequire.NoError(t, err)\\n\\n\\t// send request\\n\\tres, err = http.DefaultClient.Get(fmt.Sprintf(\\"%s/test/test/api/v1\\", proxyURL))\\n\\trequire.NoError(t, err)\\n\\trequire.Equal(t, http.StatusNotFound, res.StatusCode)\\n}\\n\\n```"},{"id":"/go_web_started","metadata":{"permalink":"/blog/go_web_started","source":"@site/blog/go_web_started.md","title":"Golang Web Starter","description":"Golang Web Starter","date":"2024-07-10T13:16:41.000Z","formattedDate":"July 10, 2024","tags":[{"label":"go","permalink":"/blog/tags/go"}],"readingTime":6.51,"truncated":false,"authors":[{"name":"Mike Wang","title":"Software Engineer","url":"https://github.com/mikechesterwang","imageURL":"https://avatars.githubusercontent.com/u/52522981","key":"mike"}],"frontMatter":{"title":"Golang Web Starter","description":"Golang Web Starter","authors":["mike"],"tags":["go"],"hide_table_of_contents":false},"prevItem":{"title":"Go HTTP Reverse Proxy","permalink":"/blog/go_reverse_proxy"},"nextItem":{"title":"Index","permalink":"/blog/index"}},"content":"Web development with Golang is a hot topic. There are many frameworks and tools to choose from. Essentially, there are several parts you need to set up at the very beginning:\\n\\n1. **API specification** \\n2. **Database access** (no ORM, but with interfaces)\\n3. **Dependency injection** \\n4. **Test framework** (high coverage, even with many external services)\\n5. **Development environment** (use dev container, instant code reload)\\n\\nI\'ve been working on web development with Golang for a while. In this article, I will share my experience with you.\\nThe code in this article can be found in here: [https://github.com/xich-dev/go-starter](https://github.com/xich-dev/go-starter) \\n\\n## API Specification\\n\\nAPI specification is the first thing you need to do. It\'s the contract between the frontend and the backend. OpenAPI has a good ecosystem. Popular programming languages have libraries to generate code from OpenAPI specification. In Golang, `oapi-codegen` is a good choice. \\n\\nYou can also define the schemas in the OpenAPI spec, and treat it as the single source of truth of the data model. In this design pattern, you use OpenAPI spec to design your business logic instead of defining the data model in the relational databases. Sounds like a bold move, but it\'s worth trying. Eventually, you will find that the data model in the relational database is just a subset of the data model in the OpenAPI spec. Since all components in your software, in the web development scenario, the frontend, the backend, both rely on the OpenAPI spec. \\n\\nIn the following example, I first define the `SignInParams` in the OpenAPI spec. Then I can just use a single method `BodyParser` to get the request body.\\n\\n```yaml\\nSignInParams:\\n  type: object\\n  required: [phone_number, country_code, verification_code]\\n  properties:\\n    phone_number:\\n      type: string\\n    country_code:\\n      type: string\\n    verification_code:\\n      type: string\\n```\\n\\n```go\\nfunc (h *Handler) PostSignIn(c *fiber.Ctx) error {\\n    var req apigen.SignInParams\\n    if err := c.BodyParser(&req); err != nil {\\n        return c.Status(400).SendString(\\"invalid request\\")\\n    }\\n    ......\\n}\\n```\\n\\nI like [fiber](https://github.com/gofiber/fiber) because it is concise and fast. Gin is also a good choice if you prefer a more mature framework.\\nYou can generate code for the `security` field with Gin, but not with fiber as fiber is just recently supported by the `openapi-codegen` community. \\nI prefer to explicitly handle the security and parameter verification by myself with more powerful tools (I will talk about these in the future). So fiber works for me.\\n\\n## Database access \\n\\nAlthough ORM tools can save you some time, you still need to write SQL by yourself, but with interfaces in Golang. With `sqlc`, you can generate the interfaces and the SQL code from the SQL files. It can deal with the injection, while providing a more flexible and smooth development experience.\\n\\n`sqlc` does a simple grammar check for you and generates the interfaces and the SQL code. You can use the interfaces to write the business logic, and the SQL code to write the database access code. Since the generated code are Golang interfaces, that means you can use `gomock` to mock the database access code in unit tests. No more Postgres in docker container for the unit test which is supposed to be a lightweight white box. \\n\\nLet\'s take a look at the code it generates:\\n\\n```go\\ntype CreateUserParams struct {\\n\\tCountryCode string\\n\\tPhoneNumber string\\n}\\n\\nfunc (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (*User, error) {\\n\\trow := q.db.QueryRow(ctx, createUser, arg.CountryCode, arg.PhoneNumber)\\n\\tvar i User\\n\\terr := row.Scan(\\n\\t\\t&i.ID,\\n\\t\\t&i.Username,\\n\\t\\t&i.Password,\\n\\t\\t&i.Email,\\n\\t\\t&i.CreatedAt,\\n\\t\\t&i.UpdatedAt,\\n\\t\\t&i.CountryCode,\\n\\t\\t&i.PhoneNumber,\\n\\t)\\n\\treturn &i, err\\n}\\n```\\n\\nYou can see that the `CreateUser` method is generated with the `CreateUserParams` struct. You can use the `CreateUser` method in the business logic. No db connection and no SQL (or SQL wrapper) in the business logic. \\n\\nThen you can make it an interface:\\n\\n```go\\ntype ModelInterface interface {\\n\\tquerier.Querier\\n\\tRunTransaction(ctx context.Context, f func(model ModelInterface) error) error\\n\\tInTransaction() bool\\n}\\n```\\n\\nThis allows you to decouple the business logic from the database access code. And you can use `gomock` to mock the database access code in the unit tests. We will talk about it later in this article.\\n\\n\\n## Dependency injection\\n\\nIf you are a big fan of mocking and testing, then you will have a lot of interfaces in your code. In that case, you need to inject the implementation of the interfaces into the business logic. [wire](https://github.com/google/wire) is a good choice. What you need to do is writing constructors for the implementations and the business logic, and then `wire` will sort out the dependency graph, and generates a bulletproof initialization code for you.\\n\\nFor instance, you have the following components in your code:\\n\\n```go\\nfunc NewConfig() error\\n\\nfunc NewModel(cfg *config.Config) (model.ModelInterface, error)  \\n\\nfunc NewCloudService(cfg *config.Config, model model.ModelInterface) (service.CloudInterface, error)\\n\\nfunc NewTradeService(cfg *config.Config, model model.ModelInterface) (service.TradeInterface, error)\\n\\nfunc NewController(cloud service.CloudInterface, trade service.TradeInterface) (controller.ControllerInterface, error)\\n\\nfunc NewServer(cfg *config.Config, controller controller.ControllerInterface) *Server\\n```\\n\\nTo initialize the `Server`, you can just put the constructors in the `wire.go` file:\\n\\n```go\\nfunc InitializeServer() (*Server, error) {\\n    wire.Build(\\n        NewConfig,\\n        NewModel,\\n        NewCloudService,\\n        NewTradeService,\\n        NewController,\\n        NewServer,\\n    )\\n    return &Server{}, nil\\n}\\n```\\n\\nThen run `wire` to generate the initialization code. No need to handle the complex dependency graph by yourself. A single initialize function is not difficult to write. But when the development goes on, the dependency graph is changing and the initialization code is getting more and more complex. You don\'t need to review and rewrite the dependency graph everytime you change it, `wire` can save you a lot of time.\\n\\n\\n## Test Framework\\n\\nJust use [gomock](https://github.com/uber-go/mock). It\'s powerful and easy to use. That\'s where you can get the most benefit from the interfaces. \\nRemember the `ModelInterface` in the previous section? You can use `gomock` to mock the database access code in the unit tests. \\n\\n```go\\nfunc TestSignInService(t *testing.T) {\\n    ctrl := gomock.NewController(t)\\n    defer ctrl.Finish()\\n\\n    mockModel := model.NewMockModelInterface(ctrl)\\n    mockModel.\\n        EXPECT().\\n        CreateUser(gomock.Any(), querier.CreateUserParams{\\n            CountryCode: \\"+86\\",\\n\\t        PhoneNumber: \\"123456\\", \\n        }).\\n        Return(&querier.User{\\n            ID: uuid.New(),\\n        }, nil)\\n    \\n    service := NewSignInService(mockModel)\\n    user, err := service.SignIn(context.Background(), \\"+86\\", \\"123456\\")\\n    ...\\n}\\n```\\n\\nHere, we are testing the `SignIn` method in the `SignInService`. We mock the `CreateUser` method in the `ModelInterface` and return a fake user. Then we can test the `SignIn` method with the fake user without touching the database. `gomock` can also help you to check if the method is called with the correct parameters.\\n\\n## Development environment\\n\\nDocker-compose can help you to set up a development environment where all your WSL and Mac co-workers can work with. \\n\\nLet\'s have a Dockerfile for our dev container at first.\\n\\n```Dockerfile\\nFROM XXX\\n\\nWORKDIR /app\\n\\nCOPY --from=golang:1.22-alpine /usr/local/go/ /usr/local/go/\\n \\nENV PATH=\\"/usr/local/go/bin:${PATH}\\"\\n\\nENTRYPOINT []\\n\\n```\\n\\nYou may wonder why using `COPY --from=golang:1.22-alpine` instead of `FROM golang:1.22-alpine`. Well, you can do that. But if you want to use other image like `jrottenberg/ffmpeg:4.4-alpine` while Golang is also needed, just use the `COPY --from` syntax to get the Golang binary. \\n\\nSince containers are nothing but a Linux process, it can be lightweight and fast. You can do \\"Hot Reload\\" with `docker-compose`.\\n\\n```yaml\\nversion: \\"3.9\\"\\nservices:\\n  dev:\\n    build: \\n      dockerfile: ./Dockerfile.dev\\n    ports:\\n      - \\"8000:8000\\"\\n    command:\\n    - go\\n    - run\\n    - cmd/main.go\\n    environment:\\n      XICFG_PORT: 8000\\n    volumes:\\n      - ./:/app\\n      - dev-go-data:/root/go/pkg/mod\\n      - dev-go-build-data:/root/.cache/go-build\\n  db: \\n    image: \\"postgres:latest\\"\\n    ports:\\n      - \\"5432:5432\\"\\n    environment:\\n      POSTGRES_PASSWORD: postgres\\n    volumes:\\n      - db-data:/var/lib/postgresql/data\\nvolumes:\\n  db-data:\\n  dev-go-data:\\n  dev-go-build-data:\\n```\\n\\nHere, we mount the go cache to the docker volumes so that everytime the container is restarted, the go cache is still there. The development experience is just like developing on your local machine. You might also have some external services like Postgres, just put them in the docker-compose as well.\\n\\nWith this setup, you can run `docker-compose restart dev` to restart your dev container. I also bind the command to the `Ctrl + S`, so that everytime I save the code, \\nthe dev container will restart and the code will be recompiled. Since in web development, the states are stored in the database, so it is sort of a hot reload."},{"id":"/index","metadata":{"permalink":"/blog/index","source":"@site/blog/index.md","title":"Index","description":"Education Background: SUSTech (2017 - 2022), Financial Engineering, Computer Science","date":"2024-07-10T13:16:41.000Z","formattedDate":"July 10, 2024","tags":[{"label":"mcw","permalink":"/blog/tags/mcw"}],"readingTime":0.74,"truncated":false,"authors":[{"name":"Mike Wang","title":"Software Engineer","url":"https://github.com/mikechesterwang","imageURL":"https://avatars.githubusercontent.com/u/52522981","key":"mike"}],"frontMatter":{"title":"Index","authors":["mike"],"tags":["mcw"],"hide_table_of_contents":false},"prevItem":{"title":"Golang Web Starter","permalink":"/blog/go_web_started"},"nextItem":{"title":"A Glimpse of the Kubernetes Pod Exec Interface","permalink":"/blog/kubernetes_exec_code_view"}},"content":"**Education Background**: SUSTech (2017 - 2022), Financial Engineering, Computer Science\\n\\n**6+ years software development experience**\\n\\n    1. 2018.6 - 2021.2 Independent developer. Served more than 10 customers and developed 20+ projects (Spring Boot, PHP, MySQL, React Native, Docker). Lab Assistant. Developed a high performance dynamic distributed large graph partitioning algorithm. (C++, MPI)\\n\\n    2. 2021.2 - 2021.6 Internship at a fund house. Developed a complete quantitative trading strategy analysis system and daily work automation platform. (Python, React) \\n    \\n    3. 2021.6 - 2021.12 Founder of Xich-Tech, focusing on Law Tech. Served more than 10 law firms and 3000+ lawyers. (JavaScript, Chromium, Electron, React, Node.js, MQ)\\n\\n    4. 2021.12 - 2022.5 Internship at RisingWave Labs. Full-stack development.Developed a high performance DAG visualization framework. (JavaScript, React, AWS)\\n\\n    4. 2022.5 - Now Full-time software enginner at RisingWave Labs. Focusing on cloud architecture design and development. (Go, Kubernetes, RisingWave, Postgresql, AWS)\\n\\n**Keywords**: Full-stack, Cloud, DevOps, Business Solution."},{"id":"/kubernetes_exec_code_view","metadata":{"permalink":"/blog/kubernetes_exec_code_view","source":"@site/blog/kubernetes_exec_code_view.md","title":"A Glimpse of the Kubernetes Pod Exec Interface","description":"A Glimpse of the Kubernetes Pod Exec Interface","date":"2024-07-10T13:16:41.000Z","formattedDate":"July 10, 2024","tags":[{"label":"Kubernetes","permalink":"/blog/tags/kubernetes"}],"readingTime":5.7,"truncated":false,"authors":[{"name":"Mike Wang","title":"Software Engineer","url":"https://github.com/mikechesterwang","imageURL":"https://avatars.githubusercontent.com/u/52522981","key":"mike"}],"frontMatter":{"title":"A Glimpse of the Kubernetes Pod Exec Interface","description":"A Glimpse of the Kubernetes Pod Exec Interface","authors":["mike"],"tags":["Kubernetes"],"hide_table_of_contents":false},"prevItem":{"title":"Index","permalink":"/blog/index"},"nextItem":{"title":"A Glimpse of the Kubernetes Scheduler","permalink":"/blog/kubernetes_scheduler"}},"content":"## User-facing Interface\\nWith `go-client`, users can run command in a container using the following code\\n```go\\nvar (\\n    podName      = \\"pod-name\\"\\n    podNamespace = \\"pod-namespace\\"\\n    cmd          = []string{\\"echo\\", \\"1\\"}\\n)\\n\\n// build RESTful request\\nreq := t.kc.\\n\\tCoreV1().\\n\\tRESTClient().\\n\\tPost().\\n\\tResource(\\"pods\\").\\n\\tName(podName).\\n\\tNamespace(podNamespace).\\n\\tSubResource(\\"exec\\")\\nexecOption := &corev1.PodExecOptions{\\n\\tCommand: cmd,\\n\\tStdout:  true,\\n\\tStderr:  true,\\n    // we only care about not tty case in this example.\\n\\tTTY:     false,\\n    Stdin:   false,\\n}\\nreq.VersionedParams(execOption, scheme.ParameterCodec)\\n\\n// execute command in container using SPDYExecutor\\nexec, err := t.newSPDYExecutor(t.kc.GetRestCfg(), \\"POST\\", req.URL())\\nif err != nil {\\n\\treturn \\"\\", errors.Wrapf(err, \\"failed to build SPDY Executor: %v\\", option)\\n}\\n\\noutBuf := new(bytes.Buffer)\\nerrBuf := new(bytes.Buffer)\\n\\nerr = exec.StreamWithContext(ctx, remotecommand.StreamOptions{\\n\\tStdin:  nil,\\n\\tStdout: outBuf,\\n\\tStderr: errBuf,\\n})\\n\\nif err != nil {\\n\\treturn \\"\\", errors.Wrapf(err, \\"failed to execute command: %v, stderr: %s\\", option, errBuf.String())\\n}\\n```\\n\\nIn the above example, we use SPDYExecutor (note that SPDY is a protocol that is deprecated in favor of HTTP/2) to execute the command in the container. The `StreamWithContext` method will send a request to the kube-apiserver, and the kube-apiserver will forward the request to the kubelet. \\n\\nThe user interface is very clean. But we don\'t know if this method will return error when the command exuected in the container returns a non-zero exit code! So we\'d better to take a deeper look. Of course, you can also verify it by executing a command in a container that will return a non-zero exit code like `exit 1`.\\n\\nLet\'s look at the `StreamWithContext` method:\\n\\n```go\\nfunc (e *streamExecutor) StreamWithContext(ctx context.Context, options StreamOptions) error {\\n\\tconn, streamer, err := e.newConnectionAndStream(ctx, options)\\n\\tif err != nil {\\n\\t\\treturn err\\n\\t}\\n\\tdefer conn.Close()\\n\\n\\tpanicChan := make(chan any, 1)\\n\\terrorChan := make(chan error, 1)\\n\\tgo func() {\\n\\t\\tdefer func() {\\n\\t\\t\\tif p := recover(); p != nil {\\n\\t\\t\\t\\tpanicChan <- p\\n\\t\\t\\t}\\n\\t\\t}()\\n\\t\\terrorChan <- streamer.stream(conn)\\n\\t}()\\n\\n\\tselect {\\n\\tcase p := <-panicChan:\\n\\t\\tpanic(p)\\n\\tcase err := <-errorChan:\\n\\t\\treturn err\\n\\tcase <-ctx.Done():\\n\\t\\treturn ctx.Err()\\n\\t}\\n}\\n```\\n\\nThe logic is simple: if the error stream is not empty (also not EOF), it will be decoded and sent to the channel `errorChan`. Otherwise, nil will be sent to the channel.\\n\\nIn normal situation (no timeout and no panic), this method will be blocked by the channel `errorChan`, where the error or nil comes out.  \\n\\nFollowing the method `streamer.stream(conn)`, we can find where the channel is created in `k8s.io/client-go/tools/remotecommand/errorstream.go`:\\n```go\\nfunc watchErrorStream(errorStream io.Reader, d errorStreamDecoder) chan error {\\n\\terrorChan := make(chan error)\\n\\n\\tgo func() {\\n\\t\\tdefer runtime.HandleCrash()\\n\\n\\t\\tmessage, err := io.ReadAll(errorStream)\\n\\t\\tswitch {\\n\\t\\tcase err != nil && err != io.EOF:\\n\\t\\t\\terrorChan <- fmt.Errorf(\\"error reading from error stream: %s\\", err)\\n\\t\\tcase len(message) > 0:\\n\\t\\t\\terrorChan <- d.decode(message)\\n\\t\\tdefault:\\n\\t\\t\\terrorChan <- nil\\n\\t\\t}\\n\\t\\tclose(errorChan)\\n\\t}()\\n\\n\\treturn errorChan\\n}\\n```\\n\\nNote that when the error stream is not empty, it does not neccessary to be an error. Because `d.decode(message)` is used to parse the error instead of something like `json.Unmarshal`. In `errorDecoderV4`, you can find the following code segment:\\n```go\\nfunc (d *errorDecoderV4) decode(message []byte) error {\\n\\t...\\n\\tcase metav1.StatusSuccess:\\n\\t\\treturn nil\\n\\t...\\n```\\n\\nBut where is the `errorStream`? It is in `k8s.io/client-go/tools/remotecommand/v2.go`.\\n```go\\nfunc (p *streamProtocolV2) createStreams(conn streamCreator) error {\\n\\tvar err error\\n\\theaders := http.Header{}\\n\\t// set up error stream\\n\\theaders.Set(v1.StreamType, v1.StreamTypeError)\\n\\tp.errorStream, err = conn.CreateStream(headers)\\n\\tif err != nil {\\n\\t\\treturn err\\n\\t}\\n\\t// set up stdin stream\\n\\tif p.Stdin != nil {\\n\\t\\theaders.Set(v1.StreamType, v1.StreamTypeStdin)\\n\\t\\t...\\n\\t}\\n\\t// set up stdout stream\\n\\t...\\n\\t// set up stderr stream\\n\\t...\\n\\treturn nil\\n}\\n```\\nThis method uses `conn.CreateStream` to create a bidirection streaming channel. It uses the header to filter the stream type. For instance, if the header is `v1.StreamTypeStdin`, the stream will be used to send data to the container. So the client will open at most **four** streaming tunnel to the container. \\n\\nTo find out what kinds of stream frames will be sent from the server side, let\'s take a look at the Kubelet.\\n\\nThe Kubernetes client (e.g. client go, Kubectl) alwasy send requests to the API Server. In this scenario, API server will forward the request to Kubelet. Kubelet actually acts as a proxy to forward traffic between the client and the container.\\n\\n## Kubernetes Side\\nHow does Kubelet handle this request? Following the source code, we can quickly find the function `InstallDebuggingHandlers` in `pkg/kubelet/server/server.go`:\\n```go\\n// InstallDebuggingHandlers registers the HTTP request patterns that serve logs or run commands/containers\\nfunc (s *Server) InstallDebuggingHandlers() {\\n    ...\\n    ws = new(restful.WebService)\\n    ws.\\n        Path(\\"/exec\\")\\n    ws.Route(ws.GET(\\"/{podNamespace}/{podID}/{containerName}\\").\\n        To(s.getExec).\\n        Operation(\\"getExec\\"))\\n    ...\\n}\\n```\\n*Accoriding the function name, we know `exec` is actually a debugging feature in Kubelet. More debug features can be found in `InstallDebuggingDisabledHandlers`*\\n\\n```go\\nfunc (s *Server) getExec(request *restful.Request, response *restful.Response) {\\n\\t...\\n\\turl, err := s.host.GetExec(podFullName, params.podUID, params.containerName, params.cmd, *streamOpts)\\n\\tif err != nil {\\n\\t\\tstreaming.WriteError(err, response.ResponseWriter)\\n\\t\\treturn\\n\\t}\\n\\tproxyStream(response.ResponseWriter, request.Request, url)\\n    ...\\n}\\n\\n```\\n`getExec` will first call `kubeGenericRuntimeManager.GetExec`, which will send an internal gRPC request to the remote runtime service to get a URL. Then `proxyStream` will use this URL to connect to the streaming endpoint.\\n\\n## Container Runtime Side\\nThe remote runtime service is the container runtime, for instance, in `containerd/pkg/cri/streaming` of the `containerd` repo, it exposes the following streaming interfaces:\\n```go\\ntype Server interface {\\n\\thttp.Handler\\n    ...\\n\\tGetExec(*runtimeapi.ExecRequest) (*runtimeapi.ExecResponse, error)\\n\\tGetAttach(req *runtimeapi.AttachRequest) (*runtimeapi.AttachResponse, error)\\n\\tGetPortForward(*runtimeapi.PortForwardRequest) (*runtimeapi.PortForwardResponse, error)\\n    ...\\n}\\n```\\n\\nIn its source code, we can find the corresponding function for handing the command execution request in `containerd/pkg/cri/streaming/remotecommand/exec.go`:\\n```go\\nfunc ServeExec(w http.ResponseWriter, req *http.Request, executor Executor, podName string, uid types.UID, container string, cmd []string, streamOpts *Options, idleTimeout, streamCreationTimeout time.Duration, supportedProtocols []string) {\\n\\tctx, ok := createStreams(req, w, streamOpts, supportedProtocols, idleTimeout, streamCreationTimeout)\\n\\tif !ok {\\n\\t\\t// error is handled by createStreams\\n\\t\\treturn\\n\\t}\\n\\tdefer ctx.conn.Close()\\n\\n\\terr := executor.ExecInContainer(podName, uid, container, cmd, ctx.stdinStream, ctx.stdoutStream, ctx.stderrStream, ctx.tty, ctx.resizeChan, 0)\\n\\tif err != nil {\\n\\t\\tif exitErr, ok := err.(utilexec.ExitError); ok && exitErr.Exited() {\\n\\t\\t\\trc := exitErr.ExitStatus()\\n\\t\\t\\tctx.writeStatus(&apierrors.StatusError{ErrStatus: metav1.Status{\\n\\t\\t\\t\\tStatus: metav1.StatusFailure,\\n\\t\\t\\t\\tReason: remotecommandconsts.NonZeroExitCodeReason,\\n\\t\\t\\t\\tDetails: &metav1.StatusDetails{\\n\\t\\t\\t\\t\\tCauses: []metav1.StatusCause{\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tType:    remotecommandconsts.ExitCodeCauseType,\\n\\t\\t\\t\\t\\t\\t\\tMessage: fmt.Sprintf(\\"%d\\", rc),\\n\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tMessage: fmt.Sprintf(\\"command terminated with non-zero exit code: %v\\", exitErr),\\n\\t\\t\\t}})\\n\\t\\t} else {\\n\\t\\t\\terr = fmt.Errorf(\\"error executing command in container: %v\\", err)\\n\\t\\t\\truntime.HandleError(err)\\n\\t\\t\\tctx.writeStatus(apierrors.NewInternalError(err))\\n\\t\\t}\\n\\t} else {\\n\\t\\tctx.writeStatus(&apierrors.StatusError{ErrStatus: metav1.Status{\\n\\t\\t\\tStatus: metav1.StatusSuccess,\\n\\t\\t}})\\n\\t}\\n}\\n```\\n\\nWhen the command execution is done in `executor.ExecInContainer`, Kubelet will send a response to the connection by:\\n```go\\nctx.writeStatus(&apierrors.StatusError{ErrStatus: metav1.Status{\\n\\tStatus: ...,\\n}})\\n```\\nThe status describes various situations to the client. For instance, if a non-zero exit code is returned by the command in the pod, the related information (e.g. exit code) is attached to the status reponse. \\n\\nBut how exactly the command is executed in container? Following the references, we can find the implementation in `containerd/pkg/cri/sbserver/container_execsync.go`:\\n```go\\nfunc (c *criService) execInternal(ctx context.Context, container containerd.Container, id string, opts execOptions) (*uint32, error)\\n```\\nMore details can be found in this function, but we will not continue to dig into it."},{"id":"/kubernetes_scheduler","metadata":{"permalink":"/blog/kubernetes_scheduler","source":"@site/blog/kubernetes_scheduler.md","title":"A Glimpse of the Kubernetes Scheduler","description":"A Glimpse of the Kubernetes Scheduler","date":"2024-07-10T13:16:41.000Z","formattedDate":"July 10, 2024","tags":[{"label":"Kubernetes","permalink":"/blog/tags/kubernetes"}],"readingTime":1.41,"truncated":false,"authors":[{"name":"Mike Wang","title":"Software Engineer","url":"https://github.com/mikechesterwang","imageURL":"https://avatars.githubusercontent.com/u/52522981","key":"mike"}],"frontMatter":{"title":"A Glimpse of the Kubernetes Scheduler","description":"A Glimpse of the Kubernetes Scheduler","authors":["mike"],"tags":["Kubernetes"],"hide_table_of_contents":false},"prevItem":{"title":"A Glimpse of the Kubernetes Pod Exec Interface","permalink":"/blog/kubernetes_exec_code_view"},"nextItem":{"title":"Multi-tenancy Gateway","permalink":"/blog/multitenancy_gateway"}},"content":"## Scheduler\\n`kube-scheduler` is the key component to schedule new pods to existing nodes. It uses \\"informer\\" to listen \\nfor new pod that it is responsible for and new node.\\n\\nWhen there is a new pod, the pod will be added to the scheduling queue. `ScheduleOne` is called in every iteration, \\nit is responsible to try to schedule one of the pod in the scheduling queue to nodes in the \\"node cache\\". \\n\\nWhen there is a new node, the node will be added to the \\"node cache\\", all unschedulable pods will immdiately be \\ntraversed to use `scheduler.AdmissionCheck` to know if it can be scheduled to this new node. \\n\\n## Autoscaler\\nCluster autoscaler is responsible for scaling up/down the cluster. Note that it is coupled with the cloud provider \\nsince only the cloud provider can provide API to manipulate your nodes (e.g. ec2 instances).\\n\\nAutoscaler lists all unschedulable pods in every iteration. When scaling up is needed, it will call `ComputeExpansionOption` \\nto get feasible plans for scaling up. This function leverage estimator and traverse the valid node groups to get the result.\\n`binpacking_estimator` uses the simulator to simulate the schenario that the node was added to the cluster. This \\"scenario\\" \\nis described as `ClusterSnapshot`. The estimator will use `CheckPredicates` to know if the pods are okay \\nto be placed in this node. `CheckPredicates` will further call `scheduler.AdmissionCheck` to do the job.\\n\\nNote that the valid node groups is directly fetched by `(*ScaleUpOrchestrator).autoscalingContext.CloudProvider.NodeGroups()`. \\n`(*ScaleUpOrchestrator).autoscalingContext.CloudProvider` is initalized by `buildCloudProvider` in \\n`cloudprovider/builder/builder_aws.go`.\\n\\nIn AWS autoscaler, it retrives all cached ASGs (autoscaling groups), which implement the `NodeGroup` interface. The ASGs are\\ncached in `Refresh` function in every iteration. The ASGs are fetched and filterd by setting `--node-group-auto-discovery=asg:tag=xxx`."},{"id":"/multitenancy_gateway","metadata":{"permalink":"/blog/multitenancy_gateway","source":"@site/blog/multitenancy_gateway.md","title":"Multi-tenancy Gateway","description":"ingress-nginx","date":"2024-07-10T13:16:41.000Z","formattedDate":"July 10, 2024","tags":[{"label":"Kubernetes","permalink":"/blog/tags/kubernetes"}],"readingTime":1.835,"truncated":false,"authors":[{"name":"Mike Wang","title":"Software Engineer","url":"https://github.com/mikechesterwang","imageURL":"https://avatars.githubusercontent.com/u/52522981","key":"mike"}],"frontMatter":{"title":"Multi-tenancy Gateway","description":"ingress-nginx","authors":["mike"],"tags":["Kubernetes"],"hide_table_of_contents":false},"prevItem":{"title":"A Glimpse of the Kubernetes Scheduler","permalink":"/blog/kubernetes_scheduler"}},"content":"## Goal\\nRoute traffic to the backend according to the request path.\\n```\\n                                       -----------\\nhttp://gatewat.com/ns1/svc1/api/v1 --\x3e |         | --\x3e http://sv1.t1/api/v1\\n                                       | Gateway |\\nhttp://gatewat.com/ns2/svc2/api/v1 --\x3e |         | --\x3e http://sv2.t2/api/v2\\n                                       -----------\\n```\\n\\n## Key Takeaways\\n1. Ingress is just a set of routing rules. It can be placed in the namespace of the tenant. \\n2. Ingress-nginx supports `rewrite-target` annotation. It can be used to rewrite the request path.\\n\\n\\n## Example\\n1. Create `KIND` cluster using the following configuration. \\n\\n```bash\\nkind create cluster --name test --config config.yml\\n```\\n\\nconfig.yml:\\n\\n```yml\\nkind: Cluster\\napiVersion: kind.x-k8s.io/v1alpha4\\nnetworking:\\n  apiServerAddress: \\"0.0.0.0\\"\\nnodes:\\n- role: control-plane\\n  extraPortMappings:\\n  - containerPort: 32443\\n    hostPort: 32443\\n  - containerPort: 32080\\n    hostPort: 32080\\n\\n```\\n\\n2. Install ingress-nginx\\n```shell\\nhelm upgrade \\\\\\n  --install ingress-nginx ingress-nginx \\\\\\n  --repo https://kubernetes.github.io/ingress-nginx \\\\\\n  --namespace ingress-nginx \\\\\\n  --set \\"controller.service.type=NodePort\\" \\\\\\n  --set \\"controller.service.nodePorts.http=32080\\" \\\\\\n  --set \\"controller.service.nodePorts.https=32443\\" \\\\\\n  --create-namespace\\n```\\n\\n3. Create HTTP applications for testing.\\n```yml\\napiVersion: v1\\nkind: Namespace\\nmetadata:\\n  name: ns1\\n  labels:\\n    name: ns1\\n---\\napiVersion: apps/v1\\nkind: Deployment\\nmetadata:\\n  name: app1\\n  namespace: ns1\\n  labels:\\n    app: app1\\nspec:\\n  replicas: 1\\n  selector:\\n    matchLabels:\\n      app: app1\\n  template:\\n    metadata:\\n      labels:\\n        app: app1\\n    spec:\\n      containers:\\n      - name: app1\\n        image: mendhak/http-https-echo:30\\n        imagePullPolicy: IfNotPresent\\n        ports:\\n        - containerPort: 8080\\n---\\napiVersion: v1\\nkind: Service\\nmetadata:\\n  name: svc1\\n  namespace: ns1\\nspec:\\n  selector:\\n    app: app1\\n  ports:\\n    - protocol: TCP\\n      port: 8080\\n---\\napiVersion: v1\\nkind: Namespace\\nmetadata:\\n  name: ns2\\n  labels:\\n    name: ns2\\n---\\napiVersion: apps/v1\\nkind: Deployment\\nmetadata:\\n  name: app2\\n  namespace: ns2\\n  labels:\\n    app: app2\\nspec:\\n  replicas: 1\\n  selector:\\n    matchLabels:\\n      app: app2\\n  template:\\n    metadata:\\n      labels:\\n        app: app2\\n    spec:\\n      containers:\\n      - name: app2\\n        image: mendhak/http-https-echo:30\\n        imagePullPolicy: IfNotPresent\\n        ports:\\n        - containerPort: 8080\\n---\\napiVersion: v1\\nkind: Service\\nmetadata:\\n  name: svc2\\n  namespace: ns2\\nspec:\\n  selector:\\n    app: app2\\n  ports:\\n    - protocol: TCP\\n      port: 8080\\n```\\n\\n\\n4. Create routing rules\\n```yml\\napiVersion: networking.k8s.io/v1\\nkind: Ingress\\nmetadata:\\n  annotations:\\n    nginx.ingress.kubernetes.io/use-regex: \\"true\\"\\n    nginx.ingress.kubernetes.io/rewrite-target: /$2\\n  name: rewrite\\n  namespace: ns1\\nspec:\\n  ingressClassName: nginx\\n  rules:\\n  - http:\\n      paths:\\n      - path: /ns1/svc1(/|$)(.*)\\n        pathType: ImplementationSpecific\\n        backend:\\n          service:\\n            name: svc1\\n            port: \\n              number: 8080\\n---\\napiVersion: networking.k8s.io/v1\\nkind: Ingress\\nmetadata:\\n  annotations:\\n    nginx.ingress.kubernetes.io/use-regex: \\"true\\"\\n    nginx.ingress.kubernetes.io/rewrite-target: /$2\\n  name: rewrite\\n  namespace: ns2\\nspec:\\n  ingressClassName: nginx\\n  rules:\\n  - http:\\n      paths:\\n      - path: /ns2/svc2(/|$)(.*)\\n        pathType: ImplementationSpecific\\n        backend:\\n          service:\\n            name: svc2\\n            port: \\n              number: 8080\\n\\n```\\n\\n5. Test\\n```shell\\ncurl http://localhost:32080/ns1/svc1/api/v1\\ncurl http://localhost:32080/ns2/svc2/api/v1\\ncurl http://localhost:32080/ns3/svc3/api/v1\\n```"}]}')}}]);